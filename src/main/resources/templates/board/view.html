<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org"
      xmlns:sec="http://www.thymeleaf.org/extras/spring-security">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>게시글 조회</title>
    <!-- [추가] CSRF 토큰을 위한 메타 태그 -->
    <meta name="_csrf" th:content="${_csrf.token}"/>
    <meta name="_csrf_header" th:content="${_csrf.headerName}"/>
    <style>
        table { width: 80%; border-collapse: collapse; }
        th, td { border: 1px solid #ccc; padding: 10px; }
        th { background-color: #f2f2f2; text-align: center; width: 15%; }
        td { text-align: left; }
        .content-div { min-height: 400px; }
        .button-group { text-align: right; margin-top: 10px; }
        .button-group button { padding: 5px 10px; cursor: pointer; }

        .comment-container { margin-top: 20px; }
        .comment-form { margin-bottom: 20px; border: 1px solid #ccc; padding: 10px; }
        .comment-form textarea { width: 100%; min-height: 60px; margin-bottom: 5px; }
        .comment-options { text-align: right; }
        .comment-item { border-top: 1px solid #eee; padding: 10px 0; }
        .comment-header { font-size: 0.9em; color: #555; margin-bottom: 5px; }
        .comment-date { margin-left: 10px; color: #999; }
        .comment-content { margin-bottom: 5px; }
        .comment-actions button { font-size: 0.8em; padding: 2px 5px; }
        .comment-children { margin-top: 10px; }
    </style>
</head>
<body>

<h1>게시글 조회</h1>

<!--/* 컨트롤러에서 전달된 board 객체를 사용 */-->
<div th:object="${board}">
    <table>
        <colgroup>
            <col style="width: 15%;">
            <col style="width: 85%;">
        </colgroup>
        <tbody>
        <tr>
            <th>제목</th>
            <!--/* th:text를 사용하여 객체의 title 필드 값을 출력 */-->
            <td th:text="*{title}">게시글 제목이 표시됩니다.</td>
        </tr>
        <tr>
            <th>작성자</th>
            <td th:text="*{memberId}">작성자 이름이 표시됩니다.</td>
        </tr>
        <tr>
            <th>내용</th>
            <!--/* HTML 태그를 포함한 내용을 출력하기 위해 th:utext 사용 */-->
            <td>
                <div class="content-div" th:utext="*{content}">게시글 내용이 표시됩니다.</div>
            </td>
        </tr>
        </tbody>
    </table>


    <!-- 댓글 영역 시작 -->
    <div class="comment-container">
        <h4>댓글</h4>

        <!-- 댓글 작성 폼 -->
        <div class="comment-form">
            <input type="hidden" id="comment-parent-no" value="">
            <textarea id="comment-content" placeholder="댓글을 입력하세요"></textarea>
            <div class="comment-options">
                <label><input type="checkbox" id="comment-secret"> 비밀댓글</label>
                <button onclick="submitComment()">등록</button>
                <button onclick="cancelReply()" id="cancel-reply-btn" style="display:none;">취소</button>
            </div>
        </div>

        <!-- 댓글 목록 -->
        <div id="comment-list">
            <!-- 댓글이 여기에 동적으로 추가됩니다. -->
        </div>
    </div>
    <!-- 댓글 영역 끝 -->



    <div class="button-group">
        <!--/* 타임리프의 URL 표현식 @{...}을 사용하여 링크 생성 */-->
        <button type="button" th:onclick="|location.href='@{/board/list}'|">목록</button>
        <!--
          로그인한 상태이고(sec:authorize), 컨트롤러에서 전달한 isOwner가 true일 때만 버튼 표시
        -->
        <th:block sec:authorize="isAuthenticated()" th:if="${isOwner}">
            <button type="button" th:onclick="|location.href='@{/board/update/{no}(no=*{no})}'|">수정</button>
            <button type="button" th:onclick="|deleteBoard(*{no})|">삭제</button>
        </th:block>
    </div>
</div>

<script th:inline="javascript">

    const contextPath = /*[[@{/}]]*/ '/';
    const boardNo = /*[[${board.no}]]*/ null;
    const currentUsername = /*[[${#authentication.name}]]*/ null;

    // 페이지 로드 시 댓글 목록 불러오기
    document.addEventListener('DOMContentLoaded', () => {
        loadComments();
    });

    // 댓글 목록 로드 함수
    async function loadComments() {
        try {
            const response = await fetch(`${contextPath}api/comments?boardNo=${boardNo}`);

            if (response.status === 404) {
                console.log('이 게시글에는 댓글이 없습니다.');
                document.getElementById('comment-list').innerHTML = ''; // 댓글 목록을 비웁니다.
                return; // 함수 실행 중단
            }

            // 404가 아닌 다른 오류일 경우에만 실패 알림을 띄웁니다.
            if (!response.ok) {
                throw new Error(`댓글을 불러오는데 실패했습니다. (상태: ${response.status})`);
            }

            const comments = await response.json();
            const commentListEl = document.getElementById('comment-list');
            commentListEl.innerHTML = ''; // 기존 목록 초기화

            // 계층 구조를 표현하기 위해 Map 사용
            const commentMap = new Map();
            comments.forEach(c => {
                c.children = [];
                commentMap.set(c.commentNo, c);
            });

            const rootComments = [];
            comments.forEach(c => {
                if (c.parentNo) {
                    const parent = commentMap.get(c.parentNo);
                    if (parent) parent.children.push(c);
                } else {
                    rootComments.push(c);
                }
            });

            rootComments.forEach(comment => {
                const commentEl = createCommentElement(comment);
                commentListEl.appendChild(commentEl);
            });

        } catch (error) {
            console.error(error);
            alert(error.message);
        }
    }

    // 댓글 HTML 요소 생성 함수 (재귀 호출)
    function createCommentElement(comment) {
        const div = document.createElement('div');
        div.className = 'comment-item';
        div.style.marginLeft = `${(comment.depth - 1) * 20}px`; // 깊이에 따라 들여쓰기
        div.dataset.commentNo = comment.commentNo;

        let buttons = '';
        // 본인 댓글일 경우 삭제, 수정 버튼 추가
        if (!comment.isDeleted && currentUsername === comment.writerId) {
            buttons = `<button class="edit-btn" onclick="showEditForm(${comment.commentNo}, '${comment.isSecret}')">수정</button>
                       <button class="delete-btn" onclick="deleteComment(${comment.commentNo})">삭제</button>`;
        }
        // 삭제되지 않은 댓글에만 답글 버튼 추가
        if (!comment.isDeleted) {
            buttons += ` <button class="reply-btn" onclick="showReplyForm(${comment.commentNo})">답글</button>`;
        }


        div.innerHTML = `
            <div class="comment-header">
                <strong>${comment.writerId}</strong>
                <span class="comment-date">${new Date(comment.createdAt).toLocaleString()}</span>
            </div>
            <div class="comment-content">${comment.displayContent}</div>
            <div class="comment-actions">
                ${buttons}
            </div>
        `;

        // 자식 댓글이 있으면 재귀적으로 추가
        if (comment.children && comment.children.length > 0) {
            const childrenContainer = document.createElement('div');
            childrenContainer.className = 'comment-children';
            comment.children.forEach(child => {
                childrenContainer.appendChild(createCommentElement(child));
            });
            div.appendChild(childrenContainer);
        }

        return div;
    }

    // 답글 폼 보여주기
    function showReplyForm(parentNo) {
        const commentForm = document.querySelector('.comment-form');
        const targetComment = document.querySelector(`.comment-item[data-comment-no='${parentNo}']`);

        // 폼을 해당 댓글 아래로 이동
        targetComment.appendChild(commentForm);

        document.getElementById('comment-parent-no').value = parentNo;
        document.getElementById('comment-content').focus();
        document.getElementById('cancel-reply-btn').style.display = 'inline';
    }

    // [추가] 댓글 수정 폼 보여주기
    function showEditForm(commentNo, isSecret) {
        const commentItem = document.querySelector(`.comment-item[data-comment-no='${commentNo}']`);
        const contentDiv = commentItem.querySelector('.comment-content');
        const actionsDiv = commentItem.querySelector('.comment-actions');

        // 이미 수정 중인 다른 댓글이 있다면 취소
        const existingEditForm = document.querySelector('.comment-edit-form');
        if (existingEditForm) {
            const otherCommentNo = existingEditForm.closest('.comment-item').dataset.commentNo;
            cancelEdit(otherCommentNo);
        }

        const originalContent = contentDiv.innerText;
        contentDiv.style.display = 'none';
        actionsDiv.style.display = 'none';

        const editForm = document.createElement('div');
        editForm.className = 'comment-edit-form';
        const secretChecked = isSecret === 'true' ? 'checked' : '';
        editForm.innerHTML = `
            <textarea class="edit-textarea" style="width: 100%; min-height: 60px;">${originalContent}</textarea>
            <div class="edit-actions" style="text-align: right; margin-top: 5px;">
                <label><input type="checkbox" class="edit-secret" ${secretChecked}> 비밀댓글</label>
                <button onclick="submitEdit(${commentNo})">저장</button>
                <button onclick="cancelEdit(${commentNo})">취소</button>
            </div>
        `;
        commentItem.appendChild(editForm);
        editForm.querySelector('.edit-textarea').focus();
    }

    // [추가] 댓글 수정 취소
    function cancelEdit(commentNo) {
        const commentItem = document.querySelector(`.comment-item[data-comment-no='${commentNo}']`);
        const editForm = commentItem.querySelector('.comment-edit-form');
        if (editForm) {
            commentItem.removeChild(editForm);
        }
        commentItem.querySelector('.comment-content').style.display = 'block';
        commentItem.querySelector('.comment-actions').style.display = 'block';
    }

    // [추가] 댓글 수정 제출 함수
    async function submitEdit(commentNo) {
        const commentItem = document.querySelector(`.comment-item[data-comment-no='${commentNo}']`);
        const content = commentItem.querySelector('.edit-textarea').value;
        const isSecret = commentItem.querySelector('.edit-secret').checked;

        if (!content.trim()) {
            alert('댓글 내용을 입력하세요.');
            return;
        }

        const commentData = {
            commentNo: commentNo,
            content: content,
            isSecret: isSecret
        };

        const token = document.querySelector("meta[name='_csrf']").getAttribute("content");
        const header = document.querySelector("meta[name='_csrf_header']").getAttribute("content");

        try {
            const response = await fetch(`${contextPath}api/comments/${commentNo}`, {
                method: 'PUT', // 수정을 나타내는 HTTP 메소드
                headers: {
                    'Content-Type': 'application/json',
                    [header]: token
                },
                body: JSON.stringify(commentData)
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(errorText || '댓글 수정에 실패했습니다.');
            }

            alert('댓글이 수정되었습니다.');
            loadComments(); // 댓글 목록을 다시 로드하여 변경사항 반영

        } catch (error) {
            console.error(error);
            alert(error.message);
        }
    }
    // 답글 작성 취소
    function cancelReply() {
        const commentForm = document.querySelector('.comment-form');
        const container = document.querySelector('.comment-container');
        container.insertBefore(commentForm, document.getElementById('comment-list')); // 폼을 원래 위치로

        document.getElementById('comment-parent-no').value = '';
        document.getElementById('comment-content').value = '';
        document.getElementById('cancel-reply-btn').style.display = 'none';
    }


    // 댓글 등록 함수
    async function submitComment() {
        const content = document.getElementById('comment-content').value;
        const isSecret = document.getElementById('comment-secret').checked;
        const parentNo = document.getElementById('comment-parent-no').value;

        if (!content.trim()) {
            alert('댓글 내용을 입력하세요.');
            return;
        }

        const commentData = {
            boardNo: boardNo,
            content: content,
            isSecret: isSecret,
            parentNo: parentNo ? Number(parentNo) : null
        };

        // [수정] CSRF 토큰 정보를 가져옵니다.
        const token = document.querySelector("meta[name='_csrf']").getAttribute("content");
        const header = document.querySelector("meta[name='_csrf_header']").getAttribute("content");

        try {
            const response = await fetch(`${contextPath}api/comments`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    // [수정] 요청 헤더에 CSRF 토큰을 추가합니다.
                    [header]: token
                },
                body: JSON.stringify(commentData)
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(errorText || '댓글 등록에 실패했습니다.');
            }

            alert('댓글이 등록되었습니다.');
            document.getElementById('comment-content').value = '';
            document.getElementById('comment-secret').checked = false;
            cancelReply();
            loadComments();

        } catch (error) {
            console.error(error);
            alert(error.message);
        }
    }

    // 댓글 삭제 함수
    async function deleteComment(commentNo) {
        if (!confirm('정말로 이 댓글을 삭제하시겠습니까?')) return;

        // [수정] CSRF 토큰 정보를 가져옵니다.
        const token = document.querySelector("meta[name='_csrf']").getAttribute("content");
        const header = document.querySelector("meta[name='_csrf_header']").getAttribute("content");

        try {
            const response = await fetch(`${contextPath}api/comments/${commentNo}`, {
                method: 'DELETE',
                headers: {
                    // [수정] 요청 헤더에 CSRF 토큰을 추가합니다.
                    [header]: token
                }
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(errorText || '댓글 삭제에 실패했습니다.');
            }

            alert('댓글이 삭제되었습니다.');
            loadComments();

        } catch (error) {
            console.error(error);
            alert(error.message);
        }
    }


    async function deleteBoard(boardNo) {
        if (!confirm("정말로 삭제하시겠습니까?")) {
            return;
        }

        // [수정] CSRF 토큰과 헤더 이름을 meta 태그에서 가져옵니다.
        const token = document.querySelector("meta[name='_csrf']").getAttribute("content");
        const header = document.querySelector("meta[name='_csrf_header']").getAttribute("content");

        // [수정] 하드코딩된 경로 대신 contextPath를 사용합니다.
        const url = `${contextPath}board/delete/${boardNo}`;

        try {
            const response = await fetch(url, {
                method: 'DELETE',
                headers: {
                    // [수정] 요청 헤더에 CSRF 토큰을 추가합니다.
                    [header]: token
                }
            });

            if (response.ok) {
                const result = await response.text();
                if (result === 'SUCCESS') {
                    alert('게시글이 삭제되었습니다.');
                    location.href = `${contextPath}board/list`; // 목록으로 이동
                } else {
                    alert('삭제에 실패했습니다: ' + result);
                }
            } else {
                if (response.status === 403) {
                    alert('삭제할 권한이 없습니다.');
                } else {
                    alert('삭제 요청에 실패했습니다. 상태: ' + response.status);
                }
            }
        } catch (error) {
            console.error('Error:', error);
            alert('삭제 중 오류가 발생했습니다.');
        }
    }
</script>

</body>
</html>
